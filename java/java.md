# JAVA

핵심만

## 생성자
- 생성자는 변수를 초기화 하는 메서드

## final

- final이 붙은 변수는 일반적으로 선언과 동시에 초기화 함
- 인스턴스 변수는 생성자에서 초기화 하도록 가능


## 상속 :  is kind of ( ~은 ~의 한 분류다) 
- 멤버만 상속 됨 ( 생성자 & 초기화블럭 X )
- 자손 클래스의 인스턴스가 생성 될 때 조상 클래스의 인스턴트도 합쳐져서 생성 됨
- 풍부할수록 좋다 (객체지향 설계)


### 오버라이딩
- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다
- 조상 메서드보다 많은 수의 예외를 선언 할 수 없다
- 오버로딩은 기존에 없는 새로운 메서드를 정의 하는 것 / 오버라이딩은 내용을 변경 하는 것


<!-- 인터페이스 : is able to(~은 ~을 할 수 있다)(강제구현)

ex( Serializable 인터페이스 : 직렬화 할 수 있는)
강제구현하메서드는 적을수록 좋다 -->


## 다형성 

- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조 할 수 있도록 하는 것
```java
 Parent p = new Child(); // 제한적인 멤버의 사용 
```

- 참조 변수 형 변환
```java
Parent p = child; 가능 (다운 캐스팅) //생략 가능 , 자손 클래스는 조상보다 많은 멤버를 갖고 있음

Child c = (child) p (업 캐스팅) // 생략 불가 , 조상은 자손보다 멤버가 적음 
```

- 조상 메서드 오버라이딩 -> 항상 오버라이딩 된(자손) 메서드를 호출(실제 생성된 인스턴스를 따라감)
- 조상 필드 오버라이딩 -> 참조변수에 따라서 다르게 가져옴
```java
Parent p (int x =100)= new Child();
Child c(int x =200) = new Child():
p.x = 100
c.x = 200
```



## 인터페이스 

- 구현체가 인터페이스 메서드 중 일부만 구현 하려면 추상클래스로 선언해야한다
- 강제구현 메소드는 적을수록 좋다 (객체지향 설계)

### 인터페이스 다형성
- 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조 가능(형변환도 가능)
```java
Fightable f = new Fighter();
```

-인터페이스 타입의 매개변수가 갖는 의미는 메서드 호출 시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야한다는 것

```java
public void attack(Fightable f) -> Fightable을 구현한 구현클래스의 <인스턴스>를 넘겨주어야함
```

- 리턴타입이 인스턴스면 해당 인터페이스를 구현한 클래스의 <인스턴스>를 반환 한다는 것을 의미

- 강제구현 메서드가 없어도 인터페이스로 묶어 인터페이스형 참조변수로 공통점을 묶을수 있다

- default 메서드는 구현체들에게 구현을 강제하지 않는다

## 익명클래스 & 내부 클래스
- 익명클래스 : 선언과 동시에 생성
- 내부클래스 : 클래스 안의 클래스 ( 밀접한 관계 )