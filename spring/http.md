# http

## 1. 인터넷 네트워크

- 표준은 거의 TCP ( 가끔 UDP도 사용 )
- PORT - 같은 IP내에서 프로세스 구분
- DNS - 도메인 이름으로 IP를 반환 ex: google.com ( IP는 가변적이고 외우기 힘들기 떄문)

### URI

- URI = URL + URN  ( 보통 URI = URL)
- https(스키마)://www.google.com(도메인):443(포트)/search?q=hello&hf=ko(쿼리) <br>

## http 기본

- 보통 http 1.1 사용 ( http2 , http3 도 사용)

### 무상태 프로토콜
- 서버가 클라이언트 상태를 모름
- 실무에선 최대한 무상태로 설계 ( 서버 확장이 용이함 )
- 비연결성의 한계 : 3 way handshake등 시간이 늘어남

## HTTP 메시지
```java
스타트 // 응답( HTTP/1.1 200 OK / 버젼 상태코드 문구)
--------
헤더  //응답 ( contentType:appplication/json , length.. 등등 바디를 제외한 메타 데이터)
---------
공백
---------
바디 // 넘어갈 데이터들 
```

## HTTP 메서드
- URI 설계에서 가장 중요한건 ***리소스 식별***
### GET
- 조회는 최대한 GET으로
- 데이터를 보낼 땐 바디에 안담고 쿼리로 보냄 ( 지원 문제 )
### POST
- 생성 요청,데이터 처리
- 리소스도 생성 됨
- 애매하면 POST
### PUT
- 리소스가 없으면 생성
- 수정과 다르게 **기존의 데이터를 완전 없애고 씌움**
### PATCH
- 수정

## HTTP 메서드 특징

- 안전 : 호출해도 리소스 변경 X
- 멱등 : 호출마다 결과가 같음 ( 다른 요청으로 인한 데이터 변환은 고려 X)
1. GET , PUT, DELET -> 멱등 / POST -> 멱등 X
- 캐시가능 

## 클라이언트에서 서버로 데이터 전송

- 쿼리 파라미터
1. GET
2. 정렬필터 (동적 데이터)

- 메세지 바디를 통해 전송
1. POST , PUT , PATCH ...
2. 회원가입 , 상품주문 ...

- 4가지 상황
1. 정적 데이터 조회 
2. 동적 데이터 조회
3. HTML Form데이터 전송(GET,POST) // 헤더 + GET -> 쿼리 데이터 전송 , POST-> name=value 바디 데이터 전송
4. HTTP API 데이터 전송 (AJAX)

## HTTP API 설계 예시

1. 리소스만 식별 해야함
2. 수정은 PATCH 지향

- URL 설계 개념
1. 문서 
- 단일개념 (파일 하나 , 객체 인스턴스, 데이터베이스 로우 등)
2. 컬렉션
- 서버가 관리하는 리소스 디렉터리
- 서버가 리소스의 URI를 생성하고 관리
3. 스토어 
- 클라이언트가 관리하는 자원 저장소
- 클라이언트가 리소스의 URI를 알고 관리
4. 컨트롤러 (컨트롤 URI)
- 위의 방법으로 해결 못하는 추가 프로세스 실행
- 동사 직접 사용 ( /member/{id}/delete) ex: Form

## HTTP 상태코드
1. 200 
- OK 

2. 300 (리다이렉션)
- 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동
- 일시 리다이렉션 - RPG(POST/Redirect/get) <br>
 ( ex: 주문에 성공하고 반환값으로 302found와 URI정보를 줘서 GET으로 바꾸고 상세페이지로 보냄)

## 리다이렉션 이해

###  영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동

-  301 Moved Permanently-
 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
- 308 Permanent Redirect-
 301과 기능은 같음
 리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST 유지)

### 일시 리다이렉션 - 일시적인 변경( 리소스의 URI가 일시적으로 변경 따라서 검색 엔진 등에서 URL을 변경하면  안됨 )

- 302 Found -리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)

-  PRG: Post/Redirect/Get

- POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트
 새로고침해도 결과 화면을 GET으로 조회
중복 주문 대신에 결과 화면만 GET으로 다시 요청

 - 현실
 307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용
자동 리다이렉션시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제 없음

###  특수 리다이렉션



## Http 요청

### 헤더 (  HTTP 전송에 필요한 모든 부가정보 )
- **헤더 분류**
1. General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close
2. Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)
3. Response 헤더: 응답 정보, 예) Server: Apache
4. 표현 헤더 : 표현 바디 정보, 예) Content-Type: text/html, Content-Length: 3423

### 바디

- 표현 본문은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보 제공


- **협상(콘텐츠 네고시에이션)**
클라이언트가 선호하는 표현 요청
1. Accept: 클라이언트가 선호하는 미디어 타입 전달
2. Accept-Charset: 클라이언트가 선호하는 문자 인코딩
3. Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
4. Accept-Language: 클라이언트가 선호하는 자연 언어
5. 협상 헤더는 요청시에만 사용


### 쿠키

- 쿠키 정보는 항상 서버에 전송됨
- 네트워크 트래픽 추가 유발
- 최소한의 정보만 사용(세션 id, 인증 토큰)
- 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStorage) 참고
- 
 보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)

### 캐시

- 클라이언트가 요청을 보내고 응답을 받으면 그 캐시를 브라우저 캐시에 저장해놨다가 응답받는 과정을 생략하고 브라우저캐시에있는걸 사용한다

- **캐시가 없을 때**
1. 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.
2. 인터넷 네트워크는 매우 느리고 비싸다.
3. 브라우저 로딩 속도가 느리다.
4. 느린 사용자 경험


- **캐시 적용**
1. 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
2. 비싼 네트워크 사용량을 줄일 수 있다.
3. 브라우저 로딩 속도가 매우 빠르다.
4. 빠른 사용자 경험




- **캐시 시간 초과**
• 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다. -> 데이터 최종수정일을 클라와 서버를 서로 비교함


