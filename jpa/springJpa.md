# spring data jpa


같은 트랜잭션안의 엔티티는 동일성을 보장

## 쿼리메서드
- 메서드 이름으로 쿼리 생성

- jpa NameQuery( 실무 거의 안씀 ) 장점


## @Query

- @Query은 문법 오류를 잡아줌( 장점 )

- jpa는 없으면 에러를 터뜨리지만 스프링 데이터jpa는 널로 준다

##스프링 JPA 페이징

- slice ( 더보기 페이징 )

-page (일반 페이징 )

## 벌크성 수정 쿼리

- 벌크연산은 영속성컨텍스트로 관리가 안됨

## @EntityGraph

- n+1(member) 문제 // 
 Team 을 LAZY로 해두면 
Member의 전체를 가져올때 TEAM은 가짜 프록시 객체로 가져와서 실제로 팀 안의 필드들을 조회할때  실제  db안의 team의 데이터를 가져와서(select쿼리 날림) 프록시를  초기화한다
-> 페치조인으로 해결 :패치조인하면 연관된 팀을 한번에 끌고옴 (조인해서) 프록시가 아니고 실제 team객체를 가져옴
-> @EntityGraph로 findAll을 오버라이딩해서 페치조인

## JPA Hint & Lock

- sql 힌트가 아니라 jpa 구현체에게 제공하는 힌트
- 엔티티 값 하나를 바꿀때도 원본이랑 조회할 엔티티를 만들어둔다 ( 비효율적 )
- 엔티티를 바꾸는게 아닌 조회할때만 값을 바꿔줌
- LOCK -> 

