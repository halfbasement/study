- 이넘타입 @Enumerated  String 으로 추가
- 상속 테이블 @Inheritance로 전략 추가 ( 부모는 추상클래스로 선언 )
- 1:1 관계 주인(FK들어갈 테이블) 설정 : 어디든 상관없지만 주 테이블에 설정하는게 좋다 
- N:M 관계는 거의 쓰면 안된다 ( 가운데 테이블을 하나 생성해서 다대일로 풀어줘야한다 ) 



## 엔티티 설계시 주의점

- setter 사용 제한

- 모든 연관관계는 지연로딩으로( @x ToOne )


- 컬렉션은 필드에서 초기화(널문제)

- cacade 옵션

- 연관관계 편의 메서드 
## 테스트

- 설정파일은 테스트와 메인을 나누자

## 도메인개발

- 엔티티 자체가 해결 할 수 있는 것들은 엔티티 안에 비즈니스 로직을 넣음 ( 응집도 ) **

- 값을 바꿀일이 있으면 setter가 아닌 핵심 비즈니스 로직 메서드로 바꾸자


- cascade all 옵션은 해당 엔티티만 cascade대상 엔티티를 사용하는 경우만 쓰자

- 중요한 비즈니스로직은 엔티티 안에 있다 (도메인 모델 패턴 ) // 서비스단에 중요로직이있는건 ( 트랜잭션 스크립트 패턴) -> 둘중 입맛에 맞춰서 쓰자

## 동적쿼리 
- 추후 querydsl

## 변경감지와 병합(merge) 매우중요

- 따로 새로 만든 엔티티는 준영속 엔티티다 ( 관리가 안됨 )

- 준영속 엔티티 수정 방법 2가지


1. 변경감지 기능(더티체킹)

-> 영속성 컨텍스트에서 영속상태인 엔티티를 찾아서 가져온 후 , 따로 생성한 엔티티의 값을 넣어줌 ( 더티체킹 )
2. merge사용

->새로 만든 엔티티를 병합시켜버림
-> 모든 속성을 다 교체함 ( 빈 값은 널 ) 위험함

결론 : 더티체킹을 써야함

세터같은건 풀어놓지말고 메서드로 만들어놓자 ( 추적하기 편하게 )

- 핵심 비즈니스로직은 트랜잭션 안에서 처리하자


## API 요청과 응답

- 커맨드랑 쿼리를 분리하자 
ex: update 트랜잭션이 있으면 update한 엔티티를 반환하지말고 , update만 시키고 컨트롤러단에서 다시 findOne으로 찾는다

- List 를 api로 반환하면 배열안에 json이 담기는데 , 그럼 전체적인 틀이 배열로 굳어져버린다 . 즉 요구사항을 추가 할 수 없다 , 그러므로 지네릭 클래스를 하나 만들어줘서 그 안에 필드로 추가해줘야한다


## API 개발 고급

-대부분의 성능 저하는 조회에서 일어남

## API 지연로딩과 조회 성능 최적화

- xToOne을 그냥 조회했더니 무한루프에 빠짐 

  1. 양방향 걸리는곳 한 곳을 @JSONIGNORE로 막아야함
  -> 그래도 에러가 남 , 2번째 문제
  2. LAZY로 설정해두면 PROXY로 대체하는데 API에 대응하는 jackson라이브러리는 기본적으로 이 프록시객체를 json으로 생성할 수 없음 ( 예외 발생 )
Hibernate5Module 을 스프링 빈으로 등록하면 해결(스프링 부트 사용중)
 
**페치조인** (매우중요) ( xToOne 조회 )

- 페치조인 (v3) :Lazy ( n+1문제 ) -> fetch join으로 eager(조인)처럼 풀어야함( 셀렉트 쿼리가 너무 많이 나감)
- dto생성 (v4) : api스펙을 리포지토리가 의존하게됨 리포지토리를 따로 만들던가 해야함(매우 애매)

페치


## 컬렉션 조회 최적화

- dto안에 엔티티를 자료형으로 가져서도 안된다( dto로 전부 바꿔야함 )
