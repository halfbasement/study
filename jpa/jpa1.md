# jpa First

- 객체 관계는 부모가 자식을 참조 할 수 없지만,
테이블 관계는 pk로 참조하는 테이블을 참조 할 수 있다


## JPA

- 엔티티에 대응해서 쿼리가 나간다 
- jpa의 모든 데이터 변경은 트랜잭션 안에서 일어남
- jpa는 대상이 테이블이 아니고 객체이다
- jpa가 어느 db든 db방언에 맞춰서 쿼리를 날려줌

jpa에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기

## 영속성 컨텍스트(실제 jpa가 db에서 어떻게 동작하는지)

- 영속성 컨텍스트란?
    - jpa 를 이해하는데 가장 중요한 용어
    - 엔티티를 영구 저장하는 환경
    - persist는 단순히 엔티티를 영속성 컨텍스트안에 집어넣는 것(쿼리생성 X)

    -   장점 :
        - 1차 캐시에서 조회함
        - 영속성 컨텍스트 없으면 db에서 찾고 반환 , 그리고 캐시에 저장해줌

-   jpa는 변경감지 (더티체킹 ) 기능 제공
-> 1차캐시안의 스냅샷(처음들어온값) 과 방금 들어온 set된 값과 비교를해서 다르면 update쿼리를 생성
-> 커밋


1. 플러시

-  db에 쓰기지연저장소에있는 sql이 반영되는것
-  변경감지 , 수정된 엔티티 쓰기지연 sql저장소에 등록
- 영속성 컨텍스트를 플러시하는 법 
    1. flush() 직접호출
    2. 커밋 


2. 준영속 상태

- 1차 캐시에 올라간 상태가 영속상태
- 영속상태의 엔티티가 영속성 컨텍스트에서 분리

## 엔티티 매핑

- IDENTITY전략은 persist()시점에 즉시 insert해서 식별자 가져옴
- 시퀀스 방식은 미리 pk값을 가져와서 한번에 insert가능

## 연관관계 매핑 기초

- 연관관계 매핑 종류
    - 방향 : 단방향 , 양방향
    - 다중성 : N:1 , 1:N , 1:1 , N:M
    - 연관관계 주인 : 외래키의 위치를 기준으로 정한다 (@ManyToOne)

- 양방향 매핑 정리
    1. 연관관계 주인은 외래 키의 위치를 기준으로 정한다
    2. 단방향 매핑으로 일단 끝내고 , 필요할 때 @OneToMany로 역방향 조회기능을 나중에 추가한다( mappedBy는 readOnly라 테이블에 영향을 주지 않기 때문에)
    3. 만약 역방향 조회기능을 추가하려면 연관관계 주인에게 연관관계 편의 메서드를 만들어준다


## 다양한 연관관계 매핑

- 영속성 컨텍스트에서 1차캐시
    키 ( @Id값) / 밸류 ( 엔티티객체 )




 @ManyToOne [ 다대일 ]
- 제일 많은 케이스
-  연관관계 주인이 다

@oneToMany [ 일대다 ]
- 권장하진 않음( 거의 안씀 )
- 실제 건들 테이블말고 연관된 테이블까지 건드려야됨
- 객체지향적으로 살짝 손해보더라도 테이블구조랑 비슷하게 가자

@OneToOne [ 일대일 ]
- 주 테이블 or 대상 테이블 중에 외래키 선택 가능
- 외래키에 DB유니크 제약조건 추가


@ManyToMany [다대다 ]
- 실무에서 권장 X
- RDB는 정규화된 테이블 2개로 다대다 관계를 표현 할 수 없음
- 연결 테이블을 추가해서 일대다 , 다대일로 풀어야함
- 연결 엔티티 생성해서 다대일이나 , 일대다로 품 


양방향이라기보단 단방향이 두개 있는게 맞다

## 고급매핑<br>


### 상속관계매핑

- 관계형 DB는 상속 관계 X
- 대신 슈퍼타입 서브타입 관계가 있음
- 즉 객체의 상속 구조와 DB의 슈퍼 서브타입을 매핑


### 방법
- 객체로 상속하는 방법은 한가진데 , DB로 하려면 방법이 여러가지다

- @Inheritance(strategy = InheritanceType.전략이름)
    - SINGLE : 기본 , 한 테이블에 다 때려 박음
   - JOINED : 부모fk값이 pk인 테이블 생성 
        - @DiscriminatorColumn : dtype컬럼생성(구분, 있는게 좋음)
   - TABLE_PER_CLASS : 쓰면 안됨// 구현 클래스마다 테이블 전략 , 부모테이블 없애고 부모테이블의 컬럼을 자식한테 다 줘버림 ( 상속안한듯한 )

기본적으로 joined를 사용하자


### @MappedSuperclass
- 추상클래스로 엔티티를 필드만 공유하게함(공통필드) 
- BaseEntity( commonDTO ) 


결론 : 상속관계 쓰느냐? -> 정답이 없다 , 데이터가 많은경우에 JOINED를 쓰면 쿼리 때문에 성능문제도 있고 유연하게 가야한다


## 프록시와 연관관계 관리

- 프록시

    - 한 트랜잭션 안에서 == 을 맞추려고함
처음에 프록시를 호출하면 find도 프록시 반환
반대도 동일
프록시 객체는 원본 엔티티를 상속받음

- 타입비교는 instance of로 해줘야함 .getReference()로 가져온것은 프록시 객체가 반환되기 떄문에

- 하이버네이트가 getReference()를 하면 프록시를 만들어준다 , 실제 사용할 때 호출  



- 지연로딩

    - 지연 로딩 설정해두면 처음엔 연관테이블을 안가져오고 프록시로 조회함 , 
    - 실제 그 연관테이블을 사용할때 프록시가 해당 엔티티로 초기화

- 즉시로딩

    - 프록시 사용 없이 한번에 가져옴
    - 실무에서는 기본 지연로딩


- 영속성 전이

    - 특정 엔티티를 영속시킬때 연관된 엔티티도 같이 영속 시키는 것 
    - cascade옵션

- 고아객체 (orphanRemoval)
부모 엔티티와 연관관계가 끊어진 자식 엔티티 자동 삭제


## 값 타입
값타입은 객체세상을 단순화하려고 만든 것
따라서 단순하고 안전하게 다룰 수 있어야 한다

### 기본 값타입


  - 자바 기본타입 , 래퍼클래스 , String
  - 생명주기를 엔티티에 의존


### 임베디드 타입 ( 복합 값 타입 )@Embeddable


  - 엔티티의 공통적인 필드들을 객체화 시켜서 사용
  - 코드를 줄이며 객체지향적으로 사용
 -   컬렉션 값 타입 
- 임베디드 타입 같은 타입을 여러 엔티티에서 공유하면 위험함 -> 값 복사 해야함 

- 즉 세터를 사용하면 안됨

### 값 타입 컬렉션

 - 값 타입을 하나 이상 저장할 때 사용
- DB는 컬렉션을 같은 테이블에 저장 불가능
 - @ElementCollection
    @CollectionTable 사용해서 별도의 테이블생성
- 이렇게 생성한 테이블은 엔티티에 라이프사이클을              의 존함     
- 컬렉션 ( set , list 등 ) 다 지연로딩
- 값 타입은 엔티티와 다르게 식별자 개념이 없다
- 실무에서는 값타인 컬렉션 대신에 일대다 관계를 고려




## JPQL 
- 컴파일단계에서 오류를 잡아낼수있음
-객체를 대상으로 함 ( 테이블이 아님 )
-엔티티와 속성 대소문자 구분
- 별칭 필수
- 타입쿼리 ( 반환타입 지정 ) , 쿼리 (반환타입 애매할때)


### 결과조회 API

.getSingResult -> 결과가 하나가 아니면 예외터짐
.getResultList -> 결과하 없으면 빈 리스트 반환


### 프로젝션 
- select 절에 조회할 대상을 지정하는 것
- new 생성자로도 가능

### 페이징
- db방언에따라 페이징이 가능하다

### 조인 

### 서브쿼리 가능
- 서브쿼리 함수도 사용 가능(exist , all , any 등 )
- jpa 는 where과 having절, select절에서 사용 가능
- from절의 서브쿼리는 불가능


### jpql 타입 표현

- enum은 패키지명을 포함해야함



## JPQL-2

### 경로 표현식
무조건 명시적 조인이 좋음
묵시적으로 들어가면 눈으로 알아채기 힘듦
- 상태필드 ( 단순히 값을 저장하기 위한 필드 )
  1.경로 탐색 끝 
- 연관 필드 ( 연관관계를 위한 필드 )
 1.  단일 값 연관 필드 ( @ManyToOne, @OneToOne )
  - 묵시적 내부조인 발생 , 탐색 O
 
 2.  컬렉션 값 연관 필드 ( @OneToMany , @ManyToMany, 대상이 컬렉션  )
  - 묵시적 내부조인 발생 , 탐색 X
  - FROM절에서 명시적 조인으로 별칭 얻어야함


### 페치 조인 ( 매우 중요 )

- sql 조인 종류 x
- jqpl에서 성능 최적화를 위해 제공
- 즉시로딩이지만 N+1문제가 발생하지 않음
- 조인타입보다 페치조인이 우선순위를 가짐

 - 일대다 처럼 컬렉션 페치조인은 데이터가 뻥튀기 되는데 , 영속성 컨텍스트에는 중복되면 하나만 저장해준다

- 페치조인을 사용할 때만 연관된 엔티티도 함께 조회 ( 즉시 로딩 )
- 페치 조인은 객체 그래프를 한번에 조회하는 개념

- 한계 
    - 페치조인 대상에는 별칭을 주면 안됨
    -  둘 이상의 컬렉션은 페치 조인 할 수 없다
    - 컬렉션을 페치 조인하면 페이징api를 사용 할 수 없다.


## 벌크연산
- 벌크연산은 영속성 컨텍스트를 무시하고 db에 직접 쿼리
- 벌크연산 수행 -> 연산 수행 후 영속성 컨텍스트 초기화
