# jpa First

- 객체 관계는 부모가 자식을 참조 할 수 없지만,
테이블 관계는 pk로 참조하는 테이블을 참조 할 수 있다


## JPA

- 엔티티에 대응해서 쿼리가 나간다 
- jpa의 모든 데이터 변경은 트랜잭션 안에서 일어남
- jpa는 대상이 테이블이 아니고 객체이다
- jpa가 어느 db든 db방언에 맞춰서 쿼리를 날려줌

jpa에서 가장 중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기

## 영속성 컨텍스트(실제 jpa가 db에서 어떻게 동작하는지)

- 영속성 컨텍스트란?
    - jpa 를 이해하는데 가장 중요한 용어
    - 엔티티를 영구 저장하는 환경
    - persist는 단순히 엔티티를 영속성 컨텍스트안에 집어넣는 것(쿼리생성 X)

    -   장점 :
        - 1차 캐시에서 조회함
        - 영속성 컨텍스트 없으면 db에서 찾고 반환 , 그리고 캐시에 저장해줌

-   jpa는 변경감지 (더티체킹 ) 기능 제공
-> 1차캐시안의 스냅샷(처음들어온값) 과 방금 들어온 set된 값과 비교를해서 다르면 update쿼리를 생성
-> 커밋


1. 플러시

-  db에 쓰기지연저장소에있는 sql이 반영되는것
-  변경감지 , 수정된 엔티티 쓰기지연 sql저장소에 등록
- 영속성 컨텍스트를 플러시하는 법 
    1. flush() 직접호출
    2. 커밋 


2. 준영속 상태

- 1차 캐시에 올라간 상태가 영속상태
- 영속상태의 엔티티가 영속성 컨텍스트에서 분리

## 엔티티 매핑

- IDENTITY전략은 persist()시점에 즉시 insert해서 식별자 가져옴
- 시퀀스 방식은 미리 pk값을 가져와서 한번에 insert가능

## 연관관계 매핑 기초

- 연관관계 매핑 종류
    - 방향 : 단방향 , 양방향
    - 다중성 : N:1 , 1:N , 1:1 , N:M
    - 연관관계 주인 : 외래키의 위치를 기준으로 정한다 (@ManyToOne)

- 양방향 매핑 정리
    1. 연관관계 주인은 외래 키의 위치를 기준으로 정한다
    2. 단방향 매핑으로 일단 끝내고 , 필요할 때 @OneToMany로 역방향 조회기능을 나중에 추가한다( mappedBy는 readOnly라 테이블에 영향을 주지 않기 때문에)
    3. 만약 역방향 조회기능을 추가하려면 연관관계 주인에게 연관관계 편의 메서드를 만들어준다


## 다양한 연관관계 매핑

- 영속성 컨텍스트에서 1차캐시
    키 ( @Id값) / 밸류 ( 엔티티객체 )




 @ManyToOne [ 다대일 ]
- 제일 많은 케이스
-  연관관계 주인이 다

@oneToMany [ 일대다 ]
- 권장하진 않음( 거의 안씀 )
- 실제 건들 테이블말고 연관된 테이블까지 건드려야됨
- 객체지향적으로 살짝 손해보더라도 테이블구조랑 비슷하게 가자

@OneToOne [ 일대일 ]
- 주 테이블 or 대상 테이블 중에 외래키 선택 가능
- 외래키에 DB유니크 제약조건 추가


@ManyToMany [다대다 ]
- 실무에서 권장 X
- RDB는 정규화된 테이블 2개로 다대다 관계를 표현 할 수 없음
- 연결 테이블을 추가해서 일대다 , 다대일로 풀어야함
- 연결 엔티티 생성해서 다대일이나 , 일대다로 품 


양방향이라기보단 단방향이 두개 있는게 맞다

## 고급매핑<br>


### 상속관계매핑

- 관계형 DB는 상속 관계 X
- 대신 슈퍼타입 서브타입 관계가 있음
- 즉 객체의 상속 구조와 DB의 슈퍼 서브타입을 매핑


### 방법
- 객체로 상속하는 방법은 한가진데 , DB로 하려면 방법이 여러가지다

- @Inheritance(strategy = InheritanceType.전략이름)
    - SINGLE : 기본 , 한 테이블에 다 때려 박음
   - JOINED : 부모fk값이 pk인 테이블 생성 
        - @DiscriminatorColumn : dtype컬럼생성(구분, 있는게 좋음)
   - TABLE_PER_CLASS : 쓰면 안됨// 구현 클래스마다 테이블 전략 , 부모테이블 없애고 부모테이블의 컬럼을 자식한테 다 줘버림 ( 상속안한듯한 )

기본적으로 joined를 사용하자


### @MappedSuperclass
- 추상클래스로 엔티티를 필드만 공유하게함(공통필드) 
- BaseEntity( commonDTO ) 


결론 : 상속관계 쓰느냐? -> 정답이 없다 , 데이터가 많은경우에 JOINED를 쓰면 쿼리 때문에 성능문제도 있고 유연하게 가야한다
